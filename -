// import mkCustomError from "errors/CustomError.ts";
import mkCustomError from "errors/CustomError.ts";
import pool from "../db/pool.ts";
import { RowDataPacket } from "mysql2";
import nodemailer from "nodemailer";

export interface OtpRecord extends RowDataPacket {
  id: number;
  otp: string;
  attempts_left: number; // defaults to 5 in the DB
  created_at: Date;
  expires_at: Date;
}

type OtpVerifyResult = {
  status: "valid" | "expired" | "incorrect" | "noAttemptsLeft";
  msg: string;
};

export default class Otp {
  static generateNumericOTP(length = 6): string {
    return Array.from({ length }, () => Math.floor(Math.random() * 10)).join(
      "",
    );
  }

  static async send(email: string): Promise<OtpRecord> {
    const otp = this.generateNumericOTP();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000);

    // On next resend attempt:
    //
    //     SELECT cooldown_until FROM otp_resend_requests WHERE email = ? ORDER BY requested_at DESC LIMIT 1
    //
    //         If cooldown_until IS NOT NULL AND cooldown_until > NOW(), reject with an error.

    // const existing = existingRows[0];

    // Step 2: Check if it's still valid and attempts > 0
    // if (existing) {
    //   const expired = new Date(existing.expires_at) <= new Date();
    //   if (!expired && existing.attempts_left <= 0) {
    //     throw new Error("No attempts left. Wait until OTP expires.");
    //   }
    // }

    // Delete any existing OTP (if there's any) for that email before inserting a new one
    await pool.execute("DELETE FROM otps WHERE email = ?", [email]);

    await pool.execute(
      "INSERT INTO otps (email, otp, expires_at) VALUES (?, ?, ?)",
      [email, otp, expiresAt],
    );

    const transporter = nodemailer.createTransport({
      service: "gmail",
      host: "smtp.gmail.com",
      port: 587,
      secure: false,
      auth: {
        user: process.env.SKONNECT_EMAIL,
        pass: process.env.SKONNECT_PASSWORD,
      },
    });

    try {
      await transporter.sendMail({
        from: process.env.SKONNECT_EMAIL,
        to: email,
        subject: "OTP Verification",
        html: `<h3>Your OTP is: <strong>${otp}</strong><br>Use it before it expires.</h3>`,
      });
    } catch (error) {
      console.error("Failed to send email", error);
    }

    const [otpRecord] = await pool.execute<OtpRecord[]>(
      `SELECT id, otp, attempts_left, created_at, expires_at FROM otps WHERE email = ? ORDER BY created_at DESC LIMIT 1`,
      [email],
    );

    return otpRecord[0];
  }

  static async verify(email: string, otp: string): Promise<OtpVerifyResult> {
    const [rows] = await pool.execute<OtpRecord[]>(
      "SELECT * FROM otps WHERE email = ? ORDER BY created_at DESC LIMIT 1",
      [email],
    );

    const record = rows[0] ?? null;
    // gurard check if for some reason wrong email or no otp record
    if (!record)
      return { status: "incorrect", msg: "wrong email or no OTP record found" };

    if (record.expires_at < new Date())
      return {
        status: "expired",
        msg: "OTP expired, please request a new OTP",
      };

    if (record.otp !== otp)
      return { status: "incorrect", msg: "wrong OTP, please try again" };
    if (record.attempts_left <= 0)
      return {
        status: "noAttemptsLeft",
        msg: "maximum attempts reached, please request a new OTP",
      };

    return { status: "valid", msg: "OTP verficatin successful" };
  }

  static async getOtpRecordByOtp(otp?: string): Promise<OtpRecord> {
    const [otpRecord] = await pool.execute<OtpRecord[]>(
      `SELECT otp, attempts_left, created_at, expires_at FROM otps WHERE otp = ? ORDER BY created_at DESC LIMIT 1`,
      [otp],
    );

    return otpRecord[0];
  }

  static async getOtpRecordByEmail(email: string): Promise<OtpRecord | null> {
    const [rows] = await pool.execute<OtpRecord[]>(
      `SELECT id, otp, attempts_left, created_at, expires_at 
       FROM otps 
       WHERE email = ? 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [email],
    );
    return rows[0] ?? null;
  }

  static async deleteOtp(otp: string): Promise<void> {
    await pool.execute(`DELETE FROM otps WHERE otp = ?`, [otp]);
  }

  static async decrementAttempts(email: string): Promise<number> {
    // Decrement attempts_left by 1, but never below 0
    await pool.execute(
      `UPDATE otps 
       SET attempts_left = GREATEST(attempts_left - 1, 0) 
       WHERE email = ?`,
      [email],
    );

    // Return updated attempts_left count
    const [rows] = await pool.execute<OtpRecord[]>(
      `SELECT attempts_left FROM otps WHERE email = ? ORDER BY created_at DESC LIMIT 1`,
      [email],
    );

    if (rows.length === 0)
      throw new Error("OTP not found for decrementing attempts");

    return rows[0].attempts_left;
  }

  private static async checkOtpResendCountAndCooldown(email: string) {
    // const cooldownTime = new Date(Date.now() + 10 * 60 * 1000);

    //  Check for active cd and
    // most recent request time for cd time
    const [latestReqRow] = await pool.execute<RowDataPacket[]>(
      `SELECT cooldown, requested_at
   FROM otp_resend_requests 
   WHERE email = ? 
   ORDER BY requested_at DESC 
   LIMIT 1`,
      [email],
    );
    const latest = latestReqRow[0];
    // throw err if otp has cd
    if (latest.cooldown) {
      const { cooldown, requested_at } = latest;
      if (cooldown && new Date(cooldown) > new Date()) {
        mkCustomError({
          status: 401,
          errs: {
            status: "resendOtpCooldown",
            cooldownTime: requested_at,
          },
        });
      }
    }

    // Count recent requests (within 10 min window)
    const [rows] = await pool.execute<RowDataPacket[]>(
      `SELECT COUNT(*) AS recent_requests
   FROM otp_resend_requests
   WHERE email = ? AND requested_at > (NOW() - INTERVAL 10 MINUTE)`,
      [email],
    );

    const recentRequests = rows[0].recent_requests;

    // 3. Block if >= 3
    if (recentRequests >= 3) {
      throw new Error("Too many resend attempts. Please wait 10 minutes.");
    }

    // 4. Insert current request
    await pool.execute(`INSERT INTO otp_resend_requests (email) VALUES (?)`, [
      email,
    ]);

    // 5. Apply cooldown if this was the 3rd request
    if (recentRequests === 2) {
      await pool.execute(
        `UPDATE otp_resend_requests
     SET cooldown_until = NOW() + INTERVAL 10 MINUTE
     WHERE email = ? AND cooldown_until IS NULL`,
        [email],
      );
    }
  }
}
